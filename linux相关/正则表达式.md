# 正则表达式

## 0.问题的引入

```
字符串是计算机应用最广泛的处理对象之一(html网页，xml...)
并且字符串的组合规则形式多种多样的，比如：
	数字字符串“123”
	email地址字符串“88886666@qq.com”
	IP地址“192.168.31.1”
	URL字符串“www.bing.com”
	...
这些都是我们程序设计需要处理的对象，现在的问题是：
	计算机要处理这些字符串，首先用某种语言（或表达式，数据类型等等）去描述
	这些字符串的规则。
====>正则表达式(regual expreession)
```

## 1.正则表达式

```
是什么？
正则表达式是用来描述某种规则字符的表达式。脱离具体的语言的一些规则，但是现在
大多数的程序设计语言都支持或实现(有限的)正则表达式。
	perl
	python
	java
	c/c++
	c#
	GO
	...
但是每种语言中实现正则表达式的规则略有不同的。
```

## 2.正则表达式的规则

```
是描述规则字符串的表达式。
如：
	[0-9]+ 这是什么意思呢？描述怎么样的一种规则呢？
```

正则表达式也叫==匹配模式(pattern)==,它是由一组特定的字符串组成，通常用来匹配和替换文本的。

```
在正则表达式中的字符，分为两种：
	1）普通字符：只代表自己本身的字符
	2）元字符：有特定的含义（不代表自己）的字符
```

```
正则表达式的元字符
	.  匹配任一单个字符 如：a
	[] 字符组。虽然由多个字符构成，但是它仍然只是匹配单个字符，而字符组[]仅
	匹配括号内的一个字符；
	eg:
		[0123456789abcdefABCDEF] ===>[0-9a-fA-F]
		[]字符组也有一个元字符-
			-在[]内用来连接ASCII连续的字符 
	eg:描述一个可以作为C语言标识符的字符
		[_0-9a-zA-Z]
	[^]:排除字符组。匹配单个字符，匹配除了[]以内所有的单个字符
	比如：非十进制数字字符
	[^0-9]
	
	\d digtal
		匹配单个十进制数字字符
			\d <==> [0-9]
	\D  匹配单个非十进制数字字符
			\d <==> [^0-9]
	\w word
		匹配字母或数字或下划线
		\w <==> [_0-9a-zA-Z]
	\w	匹配非字母或数字或下划线
		\W <==> [^_0-9a-zA-Z]
	\s 匹配空白字符
		\s <==>[\n\r\t\v\f]
	\S 匹配非空白字符
		\S <==>[^\n\r\t\v\f]
```

```
匹配多个字符

+ 匹配一个或多个先前字符（或模式）
比如：
	09+
	==>
		09 099 0999 ....
	[0-9]+
	==> 0 1 2 123 1234 0123...

* 匹配0个或者多个先前字符(或模式)
	如：
	09*
	==>
		0 09 0999 ....
	[0-9]*
	==> ""空串 0 1 2 123 1234 0123....

? 匹配0个或1个先前字符（或模式）
	如：
	9？
	===> "" 9
	[0-9]? "" 0 1 2 ....9

{数字} 匹配固定数字的字符（或模式）
	如：
	88[0-9]{3}
	==>88000 88111 88123...
	
{最小数目，最大数组} 
	匹配至少“最小数目”到“最大数目”的先前字符（或模式）
	如：
	8{1,3}
	==> 8 88 888 
	
{最小数目,}
	匹配至少“最小数目”,上不封顶的先前字符（或模式）
	如：
	abc{1,}
	==>abc abcc abccc ...

() 作为一个整体，子模式
	如：
	(abc)(1,3)
	abc
	abcabc
	abcabcabc
	
(|) 二选一
	如：
	(abc|123){2}
	abc123
	123abc
	abcabc
	123123
```

```
转移元字符
	\ 加上 元字符==>元字符就不是元字符而是一个普通字符
	如：
	\*
	\.
	\?
	...
```

**练习**

```
1.请用正则表达式来描述一个<2^32的十六进制的数字字符串
0[xX][0-9a-fA-F]{1,8}  //0x00;0x0000 0000;
2.请用正则表达式来描述你C语言中出现的十进制数字字符串
以0开头的十进制数字只有0！
	(0|?){1,1}
非0 负数(-)和正数
	- 1个或者0个  -?
	[1-9][0-9]*
	(0|-?[1-9][0-9]*){1,1}
	
	这个 -？表明这个 - 可有可无
	*表示0个或者若干个
```

