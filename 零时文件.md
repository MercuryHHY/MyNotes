







```json 

14  {"type":0,"0":"未工作","10":"OK","20":"不需焊接"}


15  {"type":0,"0":"未工作","10":"OK","20":"NG","30":"不需2D检测"}

16 	{"type":0,"0":"未工作","10":"OK","20":"NG","30":"不需3D检测"}

17	 {"type":0,"0":"未工作","10":"OK","20":"不需辊压"}

18	{"type":0,"0":"未工作","10":"OK","20":"NG"}

19    0未工作/10OK/20NG/30不需测绝缘
{"type":0,"0":"未工作","10":"OK","20":"NG","30":"不需测绝缘"}

35：检测NG 100:检测OK
{"type":0,"35":"检测NG","100":"检测OK"}

,0/ok,1/NG
{"type":0,"0":"OK","1":"NG"}


35检测NG，50屏蔽，100检测OK
{"type":0,"35":"检测NG","50":"屏蔽","100":"检测OK"}


0无反馈 1 OK电芯 10 面积NG 20 距离NG 30 面积距离NG 
{"type":0,"0":"无反馈","1":"OK电芯","10":"面积NG","20":"距离NG","30":"面积距离NG"}


{"type":0,"1":"OK","2":"NG"}




1/E01开路NG,2/E02短路NG,3/E03欠压NG,4/E04过压NG,
5/E05跌落1NG,6/E06跌落2NG,7/E07时间1NG,8/E08时间2NG


{"type":0,"1":"E01开路NG","2":"E02短路NG","3":"E03欠压NG","4":"E04过压NG","5":"E05跌落1NG","6":"E06跌落2NG","7":"E07时间1NG","8":"E08时间2NG"}





0：无电芯 10 OK电芯 20扫码NG 25进站NG 30色标NG  40焊接NG 50CCD检测NG 60出站NG


挑战健赋值  10焊接挑战健  20裁切挑战健  30CCD挑战健
{"type":0,"10":"焊接挑战健","20":"裁切挑战健","30":"CCD挑战健"}

裁切结果 0:未裁切 10裁切OK  20裁切NG 30不需要裁切
{"type":0,"0":"未裁切","10":"裁切OK","20":"裁切NG","30":"不需要裁切"}

色标结果：0未检测 10检测OK 20检测NG 30不需要检测
{"type":0,"0":"未检测","10":"检测OK","20":"检测NG","30":"不需要检测"}


1内侧物流线 2外侧物流线
{"type":0,"1":"内侧物流线","2":"外侧物流线"}


焊接结果 0:未焊接 10焊接OK  20焊接NG 30不需要焊接
焊接结果 0:未焊接 10焊接OK  20焊接NG 30不需要焊接
{"type":0,"0":"未焊接","10":"焊接OK","20":"焊接NG","30":"不需要焊接"}


CCD检测结果 0:未检测 10检测OK  20焊印检测NG 25裁切尺寸NG 30不需要检测
{"type":0,"0":"未检测","10":"检测OK","20":"焊印检测NG","25":"裁切尺寸NG","30":"不需要检测"}




1/A1工位;2/A2工位;3/B1工位;4/B2工位
{"type":0,"1":"A1工位","2":"A2工位","3":"B1工位","4":"B2工位"}




NG类别 0：未响应 1:OK 5：已屏蔽  10:NG
NG类别 0：未响应 1:OK 5：已屏蔽  10:NG
{"type":0,"0":"未响应","1":"OK","5":"已屏蔽","10":"NG"}

NG原因 10、外观NG 20、贴胶NG 30、热熔NG 40、MES NG 50、OK


：1：包膜1号位  2：包膜2号位  3：包膜3号位 4：包膜4号位
{"type":0,"1":"包膜1号位","2":"包膜2号位","3":"包膜3号位","4":"包膜4号位"}

0:未响应  1:OK 5：已屏蔽 10:未热熔  20:面积NG 30:尺寸NG
{"type":0,"0":"未响应","1":"OK","5":"已屏蔽","10":"未热熔","20":"面积NG","30":"尺寸NG"}
{"type":0,"0":"未响应","1":"OK","5":"已屏蔽","10":"未热熔","20":"面积NG","30":"尺寸NG"}



0:未响应  1:OK 5：已屏蔽 10:未热熔  20:面积NG 30:尺寸NG
0:未响应  1:OK 5：已屏蔽 10:未热熔  20:面积NG 30:尺寸NG
0:未响应  1:OK 5：已屏蔽 10:未热熔  20:面积NG 30:尺寸NG

```







| 电芯长边1结果   |
| --------------- |
| 电芯短边1结果   |
| 贴胶检测结果    |
| 电芯长边2结果   |
| 电芯短边2结果   |
| 包膜CCD检测结果 |

```
{"type":0,"0":"未检测","1":"OK","10":"面积NG","20":"距离NG","30":"总NG"}
```



update_code1;111111111111111111111111;11111111111111;1111111111







"Hello everyone,

This is to discuss the communication integration between HMI (Human Machine Interface) and MES (Manufacturing Execution System) of the square lithium battery assembly line equipment:

The primary objective is to ensure real-time data transfer that reflects the production status of our square lithium batteries.

Our HMI is designed to capture detailed information at each stage of the assembly process. This includes parameters such as battery cell counts, assembly completion rates, quality inspection results and any defect logs.



First, we will initiate a handshake protocol to ensure that our HMI is correctly authenticated by the MES. We will then establish a structured data exchange format, probably JSON or XML, to standardise the information uploaded from our line.

We are particularly focused on minimising latency. The faster the MES receives data from the HMI, the more agile we can be in responding to unforeseen events on the line.



During this integration phase, we're also running several tests to confirm the robustness of the data transfer. It is vital that the information received by the MES is both accurate and precise to maintain the high standards of our manufacturing process.

Thank you for your consideration and I look forward to a successful integration.









"大家好、

我想和大家讨论一下方形锂电池装配线设备的人机界面（HMI）和制造执行系统（MES）之间的通信集成问题：

主要目的是确保实时数据传输，以反映我们方形锂电池的生产状态。

我们的人机界面旨在捕捉装配过程中每个阶段的详细信息。这包括电池单元数、装配完成率、质量检查结果和任何缺陷记录等参数。

我们的目标是在 HMI 和 MES 之间建立无缝数据链接。这种集成将使 MES 能够接收最新信息，从而改进生产跟踪、流程优化和预测性维护计划。

首先，我们将启动握手协议，以确保我们的人机界面得到 MES 的正确验证。然后，我们将建立结构化数据交换格式（可能是 JSON 或 XML），以规范从生产线上传的信息。

我们尤其注重尽量减少延迟。MES 从 HMI 接收数据的速度越快，我们就能越灵活地应对生产线上的突发事件。

在集成阶段，我们还进行了多次测试，以确认数据传输的稳健性。MES 接收到的信息必须准确无误，以保持我们制造流程的高标准。

如果任何人对我们如何进一步优化此通信接口有任何关注或建议，请不要犹豫让我们知道。我们的目标是共同为我们的方芯锂电池创造最高效可靠的生产环境。

谢谢您的考虑，我期待一次成功的整合。









The following is a brief description of the equipment for the assembly section of square batteries
1.







12-01 柳州瑞普问顶  BS项目

本周工作   江门M4阶段

1，极耳焊接机，与沟通PLC，使其完成与上位机的交互逻辑,

2，刷卡器与指纹模块功能测试完成（非免驱）

3，软件更新  带驱动的刷卡器功能 以及  刷卡时与PLC的权限同步

4，日常持续跟进中，配合PLC修改核对 进出站参数数据，以及双方同步  最新框架的PLC与上位机交互逻辑

5，目前所有机台基本调试完成，带料测试上位机运行正常



下周计划

完成 柳州瑞普问顶收尾工作

跟进利维能 / 吉利利信部署调试等工作









2023/12/29广 江门周报
目前进度：
1.客户延期Q机（要求设备问题点改进）
2.整线设备程序本周已完成更新，待客户检验
3.完成基本的MES配置 等待客户MES这边正式环境、确认设备需求数据等（还没有准确消息）
4.所有设备已进行跑料测试上位机各项数据采集正常 待客户检验

本周工作总结：
1.完成整线设备的程序启动服务配置 按照客户要求简化上位机启动问题
2.完成整线上位机数据的采集测试验证 解决跑料过程中遇到的数据采集异常问题：包括进出站NG异常问题、与激光刻码软件链接断断续续问题、实时数据产能出现NaN时上位机读取异常导致面板数据报错问题等。
3.完成顶盖焊设备的对接工作（配合PLC这边按照新标准程序更新）;反馈各设备plc工程师没按照新框架约定写程序导致的数据异常问题，防止后续Q机验机问题
4.MES对接PLC数据确认，交互表配置，MES配置，现在各机台已完成初版各项配置

下周计划：
1.按照客户节点完成各项需求，整线程序更新
2.根据客户时间节点进行客户这边MES对接 对一些数据确认 以及反馈部分数据无法采集问题 商量解决方案
3.配合跑料 解决现场遇到的数据等各项异常问题
4.其他





2023/12/29 江门现场上位机周报
目前项目进度：
\1. 新余赣锋，密封钉，极耳焊接机，超声波预焊机，热压机 设备的上位机已初步调试完成，其他机台陆续跟进中
2，珠海海四达  热压机，包膜机，转接片反机 ，填丝补焊，蓝胶刻码机 等设备的上位机已初步调试完成，其他机台陆续跟进中

本周工作总结：
1， 跟进处理 珠海海四达机台软件部署与调试，热压机，包膜机，转接片反机 ，填丝补焊，蓝胶刻码机，顶盖焊   沟通PLC 同步最新框架的交互逻辑，配置交互表，完成软件初步部署调试 ，上位机数据的采集测试验证
2， 跟进处理新余赣锋机台软件部署与调试，热压机，极耳焊接机 ，顶盖焊  沟通PLC 同步最新框架的交互逻辑，协调增加手持扫码枪的扫码触发信号，排查解决 电芯条码第一次进站NG数据异常，重复触发会恢复正常，问题断点调试 排查  进站时间写入异常会导致进站NG
3，完成蓝胶刻码与填丝补焊工作对接

下周计划：
继续江门M4阶段，准备出差客户现场





表达式树在实际应用中有许多用途，下面给出了几个常见的示例来说明其具体应用和使用方法。

1. LINQ 查询动态构建：使用表达式树可以动态构建 LINQ 查询中的查询条件。例如，根据用户的输入条件动态创建一个查询表达式，然后执行查询。以下是一个简单的示例：

   ```csharp
   // 构建参数表达式
   ParameterExpression productParam = Expression.Parameter(typeof(Product), "product");

   // 构建条件表达式
   BinaryExpression condition = Expression.Equal(
       Expression.Property(productParam, "Category"),
       Expression.Constant("Electronics")
   );

   // 创建Lambda表达式
   Expression<Func<Product, bool>> lambdaExpr = Expression.Lambda<Func<Product, bool>>(condition, productParam);

   // 使用动态构建的查询条件进行查询
   var query = products.Where(lambdaExpr);
   ```

2. ORM 框架的动态查询：表达式树常用于 ORM（对象关系映射）框架，可用于动态生成数据库查询语句。例如，根据用户的查询条件动态构建一个 SQL 查询语句。以下是一个示例：

   ```csharp
   // 构建参数表达式
   ParameterExpression employeeParam = Expression.Parameter(typeof(Employee), "employee");

   // 构建条件表达式
   BinaryExpression condition = Expression.AndAlso(
       Expression.Equal(Expression.Property(employeeParam, "Department"), Expression.Constant("IT")),
       Expression.GreaterThan(Expression.Property(employeeParam, "Salary"), Expression.Constant(50000))
   );

   // 创建Lambda表达式
   Expression<Func<Employee, bool>> lambdaExpr = Expression.Lambda<Func<Employee, bool>>(condition, employeeParam);

   // 使用动态构建的查询条件查询数据库
   var query = dbContext.Employees.Where(lambdaExpr);
   ```

3. 动态排序：使用表达式树可以动态构建排序逻辑，根据用户的选择动态生成排序的表达式。以下是一个示例：

   ```csharp
   // 构建参数表达式
   ParameterExpression employeeParam = Expression.Parameter(typeof(Employee), "employee");

   // 构建排序表达式
   Expression<Func<Employee, object>> sortExpr = null;
   if (sortBy == "Name")
   {
       sortExpr = Expression.Lambda<Func<Employee, object>>(Expression.Property(employeeParam, "Name"), employeeParam);
   }
   else if (sortBy == "Salary")
   {
       sortExpr = Expression.Lambda<Func<Employee, object>>(Expression.Property(employeeParam, "Salary"), employeeParam);
   }

   // 根据动态生成的排序表达式进行排序
   var sortedEmployees = employees.OrderBy(sortExpr).ToList();
   ```

4. 动态编译和执行代码：表达式树可以用于动态编译和执行代码片段，此功能在某些特定场景下非常有用。以下是一个简单的示例：

   ```csharp
   // 构建参数表达式
   ParameterExpression num1 = Expression.Parameter(typeof(int), "num1");
   ParameterExpression num2 = Expression.Parameter(typeof(int), "num2");
   
   // 构建加法表达式
   BinaryExpression addExpr = Expression.Add(num1, num2);
   
   // 创建Lambda表达式
   Expression<Func<int, int, int>> addLambda = Expression.Lambda<Func<int, int, int>>(addExpr, num1, num2);
   
   // 编译Lambda表达式，并生成可执行的委托
   Func<int, int, int> addFunc = addLambda.Compile();
   
   // 调用委托，执行加法运算
   int result = addFunc(5, 3);
   ```

这些示例只是表达式树的一些常见应用，实际上，表达式树的用途非常广泛，它可以用于很多动态编程和代码生成的场景。通过使用表达式树，我们可以在运行时动态生成、分析和执行代码，从而实现更加灵活和动态的编程需求。

















流程上，前端先显示，再落库

产品数据的mes上传状态 显示（IsPostMes），实时产生实时显示





离线上传之后，返回的BOOL，实时更新产品数据的mes上传状态 显示（IsPostMes）

离线上传。mes的流程再走一遍，注意条码绑定

如果第一次mes返回超时，那么回复写入的是503，第二次重发，mes如果回复-1，那么说明条码存在

如果直接回复1，没有超时那么直接通过







关于进出站 mes接口的调用，注意在历史数据中 分别 抽离 进出站 所需要的 参数 







1，热压机，4个一起出站，有一个出站超时，观察到有plc触发信号，可能是出站数据区的数据没读到，从日志显示上看，我的理解是数据信道读取超时（附带日志记录）

2，plc在mes出站ng时显示OK数据，原因是出站job在读取到PLC触发信号时，就已经读取到了PLC的出站数据区数据，当PLC得到我上位机出站MES NG 信号（35）时，这个时候他PLC再写入这个出站数据区，将7-1-8 数据改为 MES出站NG的值，已经晚了，上位机会显示最开始读取到的718数据，但是这个料PLC会排NG料，于是就会出现OK料但是NG排出 （前端推送之后，再进行的mes出站校验，然后PLC得到上位机的35，  IsPostMes在出站成功之后赋值为true，这个是怎么在前端）

3，顶盖焊，ads路由经常不间断 断开，从日志上看到，上位机第三次自动重连时，连接成功，但是间隔了将近1分钟，这段时间直接导致丢失了一个电芯出站数据

4，工单处理优化，工单在前端提示500异常，原因是 控制器中 数据类型发生强转时 报错了（异常但是没有catch）

5，上料使用完了之后，自动卸料并切换，从plc信号触发，计数扣除，没有料切换了就plc报警，快没有料了上位机弹框预警，上位机计数实时显示(前端处理)，注意终焊机，有两种料的消耗



1，mes出站校验的时候，将物料的相关信息（字典表中的数据）一次性发过去，mes那边会将扣除一个（具体扣除的是哪一个，我具体问了，但是mes那边回复的很模糊，他们mes的业务人员不了解具体代码），**能不能让MES提供一个当前物料剩余的mes接口**（这样咱们的处理是不是会方便些，我可以在会议上提）,

2，mes那边物料数量 是带小数点的 浮点数（这个我可以具体问问为啥）

3，当前实际的物料批次以及数量（实物）   与上位机中上料记录中  当前所使用的的物料批次以及数量，   如果不一样，今天与客户沟通，客户说没有关系，,

4，目前的临时解决方案是PLC放了固定数量的料之后会报警

5，对于长期解决方案，我思考是，PLC只管  拿辅料，没有拿到辅料  ，那么PLC就报警

上位机与MES交互，在调用MES出站接口之前，调用MES接口得到当前剩余量，

```C# 
调用MES接口得到当前剩余量
if(如果还有剩余)
{
	调用mes出站
}
else//如果没有剩余了
{
	那么调用 mes 的卸料接口，（ 同时删除本地字典表中的那一条上料记录），此时再出站，mes校验应该可以过
       //(超神波终焊)是否需要特殊处理
}


```

前端是否需要显示这个mes中的当前剩余量



业务上分析，离线模式下的生产，物料也会减少吗，减少，一旦离线模式生产，那么就会出现，MES那边还有剩余，但实际上物料已经被消耗完了，无法追溯



考虑是否可以用领域事件处理

1，一个无料报警信号到PLC

2，从字典表中提取出 上料数量，**每次出站-1** ，数量到0 的时候（数量记录可以放在字典表，也可以直接放在内存缓存新建一个数据）， 调用卸料接口，如果调用mes卸料接口返回超时且离线模式，那么数量固定到1不动

判定当前字典表中是否还有记录 可供切换，

if（true）切换就是，**MES出站时，改变上传的物料码**

else   给PLC回复无料报警信号

3，区分正反极的物料码





领域事件处理



1，上位机自动卸料不用再做，mes出站接口调用的时候，也不用再上传 "BindFeedingCodes" 这种物料码

2， 上位机条码上料，调用上料接口，MES根据设备上传的物料条码进行验证是否可用，

如果出现异常，上位机根据MES返回的信息（msg）出一个弹框提醒，提醒内容为msg内容，操作人员会根据msg内容更换条码或者修改数量进行重新上料；

3， MES提供物料查询接口，上位机新增一个**按钮**（图中的物料查询更新，名字和布局位置随意），这个按钮调用物料查询接口，更新当前设备已上物料列表，以及剩余数量；从mes获取到数据之后，在图中的**物料列表**同步显示（删除字典表中的已提交物料的本地记录，并插入从mes获取的数据）

如图

<img src="../../项目文档/BS/龙净整线/问题点收集/新增需求/1.png" style="zoom:60%;" />





4，

客户方案：

上位机出站调用MES接口，如果无法正常出站（mes返回异常，MES出站NG），上位机需要弹窗将当前出站失败原因进行显示（弹窗内容是MES的msg），异常处理完成后再进行出站（再次调用MES出站接口）



针对客户方案的个人思考：

**这里我始终觉得不对劲，所以3-7号的会议 我没有直接回复客户说可以，只是说要和上面大哥确认一下这逻辑是否正确**

这里，客户想要上位机在第一次调用mes出站接口时，如果MES回复-1表示MES出站NG，那么上位机需要弹窗将当前出站失败原因进行显示（弹窗内容是MES的msg），并且机台停机报警（机台所有动作全部停下）

异常处理完成后再进行出站（这里客户说要提供一个按钮，点击这个按钮之后  再次调用MES出站接口，并且告诉PLC可以继续刚刚那个没有出站的电芯可以出站了，并且机台恢复正常运行）

**但是这里如果有多个条码出站呢，并发的时候上位机会不会有风险**

1，PLC的程序报警之后，在恢复正常， 是否还可以继续回到处理出站那里的逻辑？,

2，我们的机台设备， 如果PLC是控制的双工位出站的呢（入壳机一次性出两个，有两次触发），会不会有冲突？

比如说一个是MES判定OK的，另一个是MES出站NG的（要处理异常之后才能继续），那这个出站逻辑PLC是否可行？

3，如果同时两个 都是MES出站NG的，那上位机如何弹框，弹两个框吗？

4，这个按钮的逻辑，我个人理解用MediatR（领域事件）处理会不会方便些

5，如果这个操作员错误操作，此时点击按钮处理之后，此时调用MES出站接口又是NG，此时如何处理





个人解决方案：

其实上面的一切，客户只是为了处理 MES出站NG的情况，只是需要重新调用MES出站接口，



第一种方案：

那在离线上传按钮的旁边  做一个**MES出站的按钮**（与离线上传极其类似，只是这个按钮只调用MES出站接口），是不是可以解决问题 

这样，设备机台不用停机报警 全部停下，有料就继续做，只是如果生产了MES出站的NG料，操作员要在上位机这里手动选择要调用的条码，上位机在NG原因那里，可以显示出msg的信息



第二种折中方案：

在出站调用mes出站接口的时候，领域事件发布处理，在出站job中领域事件发布，如果连续3次mes出站NG，那么给PLC信号，让PLC控制停机报警，事件处理方法中  弹框，停机处理完成之后，弄一个按钮，点击之后发信号告诉PLC 可以运行了，数据还是第一种的MES出站的按钮 点击补录





建议是，不能说mes直接控制机台的运行，不能说mes一旦出现问题，机台就大量的停机（如果采用客户方案），这个后果会很严重，后面又是两边扯皮，（机台说mes造成的停机，mes说生产人员没有及时处理异常，这个异常情况可能会有非常多的原因，mes那边提供）







INSERT INTO menu (Id,IsDeleted,CreationTime,CreatorId,LastModifierId,LastModificationTime,OrderNum,State,MenuName,MenuType,PermissionCode,ParentId,MenuIcon,Router,IsLink,IsCache,IsShow,Remark,Component,Redirect,Query,TenantId) VALUES
	 ('a17726f3-1917-466d-9a08-df3ad689db40',0,'2023-11-07 21:31:32','5077d41e-090a-45c2-a37d-90988ff15cc8','5077d41e-090a-45c2-a37d-90988ff15cc8','2024-04-03 16:23:25',0,1,'模式切换',2,'mes:config','a5f21edc-a23c-4ee0-bf38-78277a763e99','',NULL,0,0,1,'模式切换',NULL,NULL,NULL,'00000000-0000-0000-0000-000000000000');



主键重复

a17726f3-1917-466d-9a08-df3ad689db40











































```
        static void Main(string[] args)
        {
            string serverAddress = "127.0.0.1";
            string username = "test1";
            string password = "123456";
            int port = 50000;

            FTP_Pro fTP_Pro = new FTP_Pro();
            fTP_Pro.FtpClient(serverAddress, port, username, password);

#if true
            //本地客户端的绝对路径
            string localFilePath = "E:\\temp\\FileService.log";
            //根目录下的相对路径
            string remoteFilePath = "\\local_filelog.txt";    
            
            fTP_Pro.UploadFile(localFilePath, remoteFilePath);

            localFilePath = "E:/文件测试文件夹/feil999.txt";
            fTP_Pro.DownloadFile(remoteFilePath, localFilePath);
        }
public void UploadFile(string localFilePath, string remoteFilePath)
{
    // 创建FTPWebRequest对象，指定上传文件的FTP地址和端口号          
    FtpWebRequest request = (FtpWebRequest)WebRequest.Create
        ($"ftp://{serverAddress}:{port}/{remoteFilePath}");
    // 指定FTP操作为上传文件
    request.Method = WebRequestMethods.Ftp.UploadFile;
    // 指定FTP服务器的登录凭证 用户名和密码
    request.Credentials = new NetworkCredential(username, password);

    // 读取本地文件的二进制内容
    byte[] fileContents = File.ReadAllBytes(localFilePath);


    //request.GetRequestStream方法  获取用于写入文件内容 的 请求流，
    // 将这个流  赋值给 Stream流
    //并使用Write方法将fileContents字节数组写入请求流中。这将把本地文件内容发送到FTP服务器。
    using (Stream requestStream = request.GetRequestStream())
    {
        // 将本地文件内容写入请求流中
        requestStream.Write(fileContents, 0, fileContents.Length);
    }
    
    // 获取FTP服务器的响应,并打印出来
    FtpWebResponse response = (FtpWebResponse)request.GetResponse();
    Console.WriteLine($"Upload file complete. Response: {response.StatusDescription}");
    response.Close();
}
```



