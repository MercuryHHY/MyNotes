





### 问题1

在工程文件中，如下图

![微信截图_20230719100322](PIC\微信截图_20230719100322.png)

TableModels文件夹中的CS文件，应该是数据库中表格的相关描述，只是

这些代码对应的数据库图形工具中的表，具体的是怎样关联起来的呢（原理是什么？），

这一个个类，类中的属性是对应数据库中表格的列，映射之后会有一个怎样的效果？？

我似乎很难根据这些表  在运行时找到对应的界面，我该怎么找呢？？（我想知道  表与运行界面的数据显示之间     关联的命名规则）

数据库中表名 有没有对应的注释，如果有，在哪里可以看到呢？？





### 问题2

为什么图像界面会看不到？？？

![微信截图_20230719112855](PIC\微信截图_20230719112855.png)



### 问题3

C#中实体对象的可序列化是什么意思？？

下面是chat  GPT 的回答：：

**是否有需要补充的**

在C#中，对象的序列化是指将对象转换为可在网络传输或存储中使用的字节流或文本数据的过程。实体对象的序列化是一种常见的操作，它允许将对象持久化、传输或在不同应用程序之间进行交互。下面是关于C#中实体对象可序列化的详解：

1. 序列化的目的：序列化可以实现以下目的之一：

   - 持久化对象：将对象保存到磁盘或数据库中，以便将来恢复为对象。
   
   - 远程过程调用（RPC）：通过网络传输对象，使远程应用程序能够使用这些对象。

   - 与其他应用程序交互：将对象传递给其他应用程序，使它们能够了解和使用该对象。

2. .NET中的序列化：在.NET框架中，使用`System.Runtime.Serialization`命名空间提供的类来实现对象的序列化和反序列化。常见的序列化方式有以下两种：

   - 二进制序列化：使用`BinaryFormatter`类将对象序列化为二进制格式的字节流，或从二进制字节流反序列化为对象。这种方式通常用于.NET应用程序之间或本地文件存储之间的序列化。

   - XML序列化：使用`XmlSerializer`类将对象序列化为可扩展标记语言（XML）格式的文本数据，或从XML文本反序列化为对象。这种方式适用于与其他平台和语言进行交互的应用程序。

3. 实体对象的可序列化：要使实体对象可序列化，需要满足以下条件：

   - 对象的类定义必须标记为`[Serializable]`特性，表示该类是可序列化的。

   - 对象的成员（字段、属性）也必须是可序列化的。可以使用`[NonSerialized]`特性排除某些成员不参与序列化。

   - 类的构造函数和方法不会被默认序列化，因为这些是行为而不是数据。

4. 序列化示例：

   ```csharp
   [Serializable]
   public class Person
   {
       public string Name { get; set; }
       public int Age { get; set; }
   
       [NonSerialized]
       private int salary;
   
       public Person(string name, int age, int salary)
       {
           Name = name;
           Age = age;
           this.salary = salary;
       }
   }
   
   // 序列化对象
   Person person = new Person("John Doe", 30, 5000);
   BinaryFormatter formatter = new BinaryFormatter();
   using (FileStream stream = new FileStream("person.dat", FileMode.Create))
   {
       formatter.Serialize(stream, person);
   }
   
   // 反序列化对象
   BinaryFormatter formatter = new BinaryFormatter();
   using (FileStream stream = new FileStream("person.dat", FileMode.Open))
   {
       Person deserializedPerson = (Person)formatter.Deserialize(stream);
   }
   ```

   在上面的示例中，`Person`类被标记为可序列化的(`[Serializable]`)，其中`Name`和`Age`属性被序列化，而`salary`字段被标记为不参与序列化。使用`BinaryFormatter`类将`Person`对象序列化为二进制文件，并通过反序列化将其恢复为`Person`对象。

需要注意的是，序列化和反序列化的性能和兼容性要求会因具体的应用场景和需求而有所不同。因此，选择合适的序列化方式和设置适当的序列化选项非常重要。





### 问题4

C#中的implements与interface有什么区别吗

**implements的使用很奇怪啊**



**下面内容是chat GPT 给出的错误答案，C#中没有implements这个关键字**！！！！！！！！！！！！





在C#中，"implements"和"interface"是不同的概念。

1. Interface（接口）：接口是一种定义了一组方法、属性和事件的合同，而不提供实现的类型。接口定义了一组规范，类或结构体可以通过实现一个或多个接口来声明它们将提供接口中定义的成员的具体实现。

2. Implements（实现）："implements"是一个关键字，用于表示一个类或结构体实现了一个或多个接口。通过使用"implements"关键字，可以在类或结构体中实现接口中定义的成员。

所以，"implements"关键字是用于表示类或结构体实现接口的过程，而"interface"关键字是用于定义接口的规范。实现接口的类或结构体使用"implements"关键字来表示它们遵循接口的合同，并提供接口中定义的功能。

下面是一个示例，展示了接口和实现之间的关系：

```csharp
interface IExampleInterface
{
    void Method1();
}

class ExampleClass : IExampleInterface
{
    public void Method1()
    {
        // 实现Method1的具体逻辑
    }
}
```

在上面的示例中，**"ExampleClass"类使用"implements"关键字实现了"IExampleInterface"接口**（？？？？？？？？？？？？？？）。这意味着"ExampleClass"类必须提供接口中定义的"Method1"方法的具体实现。

总结起来，"interface"是用于定义接口的规范，而"implements"是用于表示类或结构体实现接口的过程。





### 问题5

后缀名为".g.i.cs"的文件，应该是编译器根据     XAML语言描述的控件，布局，行为     自动生成的对应的控件代码

这些代码作为一个  部分类，与程序应用逻辑分离（模块化）

**为什么程序一旦运行，我在里面写的注释会消失呢？？？？？**



**这是GPT的回答，是否有补充说明**

**我想知道一个WPF界面显示的大致流程**，程序从哪里开始，中间进行了什么操作

**它整个工程的逻辑是怎样的？？？？？？**



还得是我军哥

个人理解：：
在编译阶段，会将所有的xaml文件转换成，或者说自动生成，cs 文件中的类代码（成为类的一部分）

那么每一次编译都会重新生成，那一部分的代码会随着你下一次的编译生成，而被清理掉

所以，在这里写的注释没有意义，下一次编译后，这里的代码就被重新生成的覆盖掉



回到主线，编译处理一次后只有CS文件中的类代码，此时执行，从静态入口开始

去执行XAML转化过来的代码，其中就指定了应用程序的初始窗口

跳过去执行，那边也是XAML已经转化好的CS代码（一个类）





在WPF中，一个界面（Window或UserControl）的大致执行流程包括以下几个步骤：

1. 构造函数（Constructor）：
   当界面被实例化时，会首先执行构造函数。你可以在构造函数中进行界面的初始化工作，例如创建对象、设置初始值等。

2. XAML解析和加载：
   WPF界面通常使用XAML来描述界面的组件和布局。在构造函数执行完毕后，WPF引擎会根据XAML文件进行解析和加载，将XAML中定义的界面元素转换为实际的对象，并将它们添加到界面的逻辑树中。

3. 依赖属性设置：
   在XAML加载后，WPF引擎会根据XAML中定义的属性值，自动设置界面元素的依赖属性。这些属性可以通过属性设置、数据绑定等方式来指定。

4. 布局和渲染：
   在依赖属性设置完成后，WPF引擎会根据界面的布局管理器（如Grid、StackPanel等）对界面元素进行布局和位置计算。然后，WPF引擎会将布局后的界面元素进行渲染，绘制界面并显示在屏幕上。

5. 事件处理和交互：
   当界面显示在屏幕上后，用户可以与界面交互，例如点击按钮、输入文本等。当用户触发交互事件时，WPF引擎会调用相应的事件处理程序（如Click事件的处理方法）来响应用户操作。

6. 生命周期管理：
   界面的生命周期包括激活、停用、关闭等阶段。在不同的阶段，界面会触发相应的生命周期事件（如Activated事件、Deactivated事件、Closed事件），你可以在这些事件中执行特定的操作。

以上是一个WPF界面显示的大致执行流程。在实际开发中，你可以根据需要重写或添加各种事件处理程序和方法来实现特定的功能和交互逻辑。





### 问题6

为什么我将设计好的WPF窗口代码  放入解决方案下的一个文件夹中，它无法运行，再次抛出异常

如图

![微信截图_20230720174856](D:\黄浒烨\TY--MD文件\Problem description\PIC\微信截图_20230720174856.png)

要给出相对路径，不然编译器找不到





### 问题7

我将WPF的窗口移动到一个文件夹下之后，它的设计器不显示了，为什么？？

GPT的回答如下

当你将 WPF 窗口移到一个新的文件夹下时，WPF 的设计器可能无法正常显示的原因可能有以下几个：

1. 文件路径引用问题：WPF 窗口中使用的资源（如样式、控件模板等）可能会使用相对路径来引用其他文件或资源。当你将窗口移到新的文件夹下时，原来的相对路径可能会发生变化，导致资源引用失败。这可能会导致设计器无法正常显示。

解决方法：检查窗口中使用的资源引用路径，并确保它们相对于窗口文件的新位置是正确的。你可以使用相对路径或绝对路径来确保资源引用的正确性。

2. 命名空间冲突：如果你在窗口代码文件中使用了明确的命名空间设置，移动窗口到新的文件夹可能会导致命名空间与其他文件冲突，从而影响设计器的显示。

解决方法：检查窗口代码文件中的命名空间设置，确保唯一性。如果必要，更新相关引用的命名空间。

3. 其他文件依赖关系：WPF 窗口可能有其他文件依赖关系，如自定义控件、转换器等。当你移动窗口到新的文件夹下时，这些文件的引用路径可能会发生变化，从而导致设计器无法正确加载和显示这些文件。

解决方法：检查窗口所依赖的其他文件，更新它们的引用路径，确保它们与窗口文件的新位置相匹配。

4. Visual Studio 缓存问题：有时，Visual Studio 缓存可能会导致设计器无法正确显示。当你移动窗口到新的文件夹下时，尝试清理 Visual Studio 缓存，并重新打开解决方案以使设计器重新加载窗口。

解决方法：关闭 Visual Studio，删除解决方案文件夹下的 `.vs` 文件夹，并重新打开解决方案以重新加载窗口。

如果问题仍然存在，可以尝试在 Visual Studio 中创建一个新的空白窗口，查看设计器是否能够正常显示。如果新窗口可以正常显示，那么问题可能在于原窗口文件或所在文件夹的设置或配置中。







### 问题8

WPF的**标记扩展**语法中 

动、静态资源扩展 以及 Binding     

看了一些资料介绍，但是 对于Binding 还是不够深刻，一知半解

具体问题  如下

​	在XAML代码中 Binding我另外一个引用中 自定义的类库代码中的   类中的  属性  

那么这个XAML代码最终  解析为C# 代码后  这个Binding  的底层逻辑是什么 ，他到底在干什么？（我是否需要深刻理解明白？）

（我目前只是知道他建立了一种连接）



**个人理解如下：：（是否有需要补充说明）**

Binding是数据源与目标之间的桥梁，一般来说  源头是逻辑层的对象及属性，目标是UI层的控件对象

使用Binding时，最重要的是设置  源和路径

UI上的元素关心的是哪个属性值的变化，或者说哪个属性值是你想送达UI元素的，那这个属性就是Binding的路径（Path）



Binding是一种自动机制，他只有传递的功能，只是跑腿

思考一个问题，如何使一个属性有能力  通知 目标 ，告诉他 Binding 的值已经改变

让属性所在的类继承实现一个   INotifyPropertyChanged 接口，利用灯泡可快捷生成

在此类中的  对应的Binding的Path 属性中的  set语句中激发一个事件

语法详情如下

```C#
public int Value3
        {
            get { return value3; }
            set { 
                value3 = value;
                //在赋值后，马上进行一个通知，通知到绑定的对象，去更新的
                //这里的参数是指 this本实例中的  Value3  属性
                // ?是指判断是否为空
                PropertyChanged?.Invoke(this, new PropertyChangedEventArgs("Value3"));
            }
        }
```





### 问题9 

C#中的属性 总给我 可存贮数据的错觉

C#中的  属性与字段 ，

如果属性只是对字段的 包装处理

那为什么代码中，并不是每一个属性都对应一个字段呢？

如果属性没有存贮数据的功能，那他在类中单独存在的意义是什么呢 ？？？





在C#中，如果没有定义属性相对应的字段，那么属性也会有默认的存储空间，他与字段别无二致

只是多了 set和get   的方法

在C#中，字段和属性成对出现是为了，在属性的方法中防止重复调用方法

如果你不需要用到  set与get方法，那么属性与字段别无二致









### 问题10

C#中DataContext

```C#
// DataContext  是当前窗口的一个属性
            ///   这个DataContext很重要
            ///   它用于指定一个对象作为数据绑定的上下文。DataContext属性通常用于将数据源与UI元素进行关联，以便在UI上显示、操作和更新数据。
            ///   用于设置这个窗口的数据来自于哪里
            ///   你必须指定你这个窗口的数据到底来源与哪一个对象
```

每一个WPF中的控件都会要有一个上下文，

如果你不指定，那么他将会去他的上一个树节点去找，并与他的上一个树节点保持一致，

如果还没有，那就层层往上找









### 问题11

**那命令处理 和事件处理有什么区别呢？？？**

Command 命令

他们是什么关系，



本质上都是委托，没有区别

只是  命令的使用，使得整个工程代码的松耦合性更强，维护起来便捷

也暗合 WPF 数据驱动的思想





### 问题12

我在异步处理中博客上面看见，主线程的ID会改变吗，为什么呢？？？

详情见连接

[关于C#中async/await的用法 - 一叶、知秋 - 博客园 (cnblogs.com)](https://www.cnblogs.com/w821759016/p/17101852.html)

主线程ID是不会变得



我看见了一句话，

主线程在等待异步操作完成的同时可以执行其他任务

那我是不是可以认为它是线程内部的并发？？？？？？

可以这样理解，没有问题





### 问题13

我之前一直很奇怪

为什么在3.0框架里面大量的出现一个特性类里面什么都没有

**如图**

**![img](file:///C:/Users/HUANGH~1/AppData/Local/Temp/msohtmlclip1/01/clip_image002.gif)**

 

这里给出个人理解：：

一个空的特性类，它仅仅代表一个标记，没有提供任何额外的功能或元数据

是不是说，使用这种标签，就意味着在反射时，不对使用这个标签的使用者做任何操作

**突然想到一个问题**

如果是像3.0那样出现一个属性有多个标签和这个标签一起用呢？？

答：

在反射时，这些特性不一定都会被用到，根据反射时具体的需要，使用这些特性的对象才会进行具体的操作

多个特性用在一个字段，属性，或者类上面，反射时根据具体的需要确定使用哪一个





### 问题14

VS中的单元测试的工程结构是怎么样的？？？

一般是一个应用程序用于启动，其他的都是类库



可是怎么具体怎么启动呢？？

测试功能怎么用呢？？





### 问题15

依赖获取，，不够清晰

[C#依赖注入_c# 依赖注入_星辉Johnson的博客-CSDN博客](https://blog.csdn.net/qq_18145031/article/details/83181937)







### 问题16

上位机在RTU通信中    应答报文的数据的解析，为什么要这样做？？？？？



### 问题17

我试过利用给定的泛型不同    可以两次注册后可以得到不同的实例

那么

依赖注入到容器中，如果一个接口被几个类继承，那么在注册时又会怎么样呢？？？



### 问题18



C# web AP i 的跨域问题怎么解决

我没看懂这人的操作，什么意思？？？

https://www.cnblogs.com/hnsongbiao/p/9375997.html

我已经按照下面的方法做了，但是没有用，为什么？？？？



要在服务器端添加`Access-Control-Allow-Origin`标头以允许从本地文件（null）进行跨域请求，可以使用以下代码示例：

```csharp
[HttpPost]
public string Post(string value1)
{
    string str = value1 + "jkjkjkjkjk";
    Console.WriteLine(str);
    // 设置响应头
    HttpContext.Response.Headers.Add("Access-Control-Allow-Origin", "http://localhost:5264");
    // 或者允许任何来源的跨域请求
    // HttpContext.Response.Headers.Add("Access-Control-Allow-Origin", "*");

    return str + "oooppppp";
}
```

在上述代码中，通过在`HttpContext.Response.Headers`中添加`Access-Control-Allow-Origin`标头来允许从本地文件（null）进行跨域请求。你可以将该标头设置为你想要允许的具体源（例如 `http://localhost:5264`），或者使用`*`来允许来自任何来源的跨域请求。

此外，确保在服务器端的响应头中还存在其他跨域标头（例如`Access-Control-Allow-Methods`，`Access-Control-Allow-Headers`等）。在需要时，可以通过类似的方式将它们添加到响应头中。

请注意，该示例假设你正在使用ASP.NET框架。如果你使用的是其他框架或自定义的HTTP服务器，可能需要不同的方法来添加响应头。









### 问题19

页面显示的底层逻辑在哪里

命令是怎么触发的呢





### 问题20

ManagerEvent类中为什么是对  局部变量的操作？？？？









### 问题21



