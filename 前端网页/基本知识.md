## 变量

在 JavaScript 中，可以使用 `var`、`let` 或 `const` 关键字声明变量。这些关键字有一些区别。

`var`：它具有**函数作用域**。在函数内部声明的 `var` 变量在整个函数范围内都是可见的。如果在函数外部声明，则成为全局变量，可以被整个程序访问。

```javascript
var x = 10; // 全局变量

function example() {
  var y = 20; // 函数内部变量
  console.log(x); // 可以访问全局变量
  console.log(y);
}

example();
```

`let`：声明的变量只在代码块（如 if、for、while、函数等）内部有效，并且不会被提升到代码块之外。

```js
function example() {
  if (true) {
    let x = 10; // 代码块内的局部变量
    console.log(x);
  }
  console.log(x); //报错，提示x未被定义
}
example();
```

`const`：用于声明常量。`const` 声明的变量是**块级作用域**，**一旦定义后就不能重新赋值**。注意，`const` 声明的是一个不可变的变量，但对象和数组等复合类型的值可以修改。

```js
const PI = 3.14159; // 常量，不可重新赋值
console.log(PI);

const arr = [1, 2, 3]; // 声明一个常量数组
arr.push(4); // 可以修改数组
console.log(arr); // [1, 2, 3, 4]
```

## 数据类型

- 数字（Number）：表示数值。可以包括整数和浮点数。
- 字符串（String）：表示文本。可以使用单引号或双引号括起来。
- 布尔值（Boolean）：表示真（true）或假（false）。
- 空值（Null）：表示空或不存在的值。
- 未定义（Undefined）：表示声明了但未初始化的变量。
- 符号（Symbol）：表示唯一的标识符。在 ES6 中引入。

```js
var numberVar = 10; // 数字
var stringVar = "Hello"; // 字符串
var booleanVar = true; // 布尔值
var nullVar = null; // 空值
var undefinedVar; // 未定义

console.log(numberVar); -->10
console.log(stringVar); -->"Hello"
console.log(booleanVar);-->true
console.log(nullVar);  -->null
console.log(undefinedVar); -->undefined
```

## 运算符

不多bb，所有的运算符都支持，包括自增、自减、三目运算符`++` `--`  `a-b>1:a?b`

## 条件语句

`if switch`不多bb了没区别

`if`中唯一要**注意**的点：`==`只能代表略等，就是不严谨等于，`===`才是最严谨的，看如下代码

```js
var num = 23;
var str = '23';
if(num == str)  --> true
if(num === str) --> false
这是由于 == 进行了一轮隐士类型转换
```

## 循环语句

基本没差别，无非就是变量作用域的一些区别

## 函数:star:

#### 声明传参方式不同

传参：**形参不需要指定类型也就是可以传任何类型参数**、其次是**不需要指定返回值类型**，根据返回的类型而定以类型

函数声明、函数表达式：函数表达式这种方式就是将函数名提取出来了而已，调用方法没区别，但需要注意，**函数表达式必须在赋值才能调用，而函数声明在赋值前就能调用**

注意：**js函数也支持递归！**

```js
var type = null;
fuc1(type); --->可以的
fuc2(type); --->不行
// 函数声明
function fuc1(type){
    return type==="Declaration";
}
// 函数表达式
var fuc2 = function(type){
    return type==="Expression";
}

fuc2(type); --->可以！
```

#### 支持箭头`=>`表达式

```js
// 传统函数
function multiply(a, b) {
  return a * b;
}
// 使用箭头函数
const multiplyArrow = (a, b) => a * b;

console.log(multiply(2, 3)); // 输出：6
console.log(multiplyArrow(2, 3)); // 输出：6
```

#### 高阶函数

**函数可以作为参数传递给其他函数，或者作为返回值返回**。这种函数接受或返回其他函数的函数被称为高阶函数

```js
function addTwoNumbers(a, b) {
  return a + b;
}
function multiplyByThree(number) {
  return number * 3;
}
//高阶函数，接受函数为参数
function calculate(func, a, b) {
  const result = func(a, b);
  return result;
}
const sum = calculate(addTwoNumbers, 2, 3);
console.log(sum); // 输出：5
const product = calculate(multiplyByThree, 4, 5);
console.log(product); // 输出：60

// 高阶函数：返回一个函数
function createMultiplier(factor) {
  return function(number) {
    return number * factor;
  };
}
const double = createMultiplier(2);
console.log(double(5)); // 输出：10
const triple = createMultiplier(3);
console.log(triple(5)); // 输出：15
```

#### 闭包

函数**可以访问其定义时所在的词法作用域**，即使函数在定义之后在其他地方执行。闭包**可以用于创建私有变量、延长变量生命周期等应用场景**

```js
//高阶函数
function outerFunction() {
  var outerVariable = 'I am from outer function';
  function innerFunction() {
    console.log(outerVariable);
  }
  //返回一个函数
  return innerFunction;
}

//closure本质就是一个函数
var closure = outerFunction();
closure(); // 输出：I am from outer function
```

#### 回调函数

类似于C#的委托回调！

```js
function sayHello() {
  console.log("Hello!");
}

function doSomething(callback) {
  setTimeout(callback, 2000); // 2秒后执行回调函数
}

doSomething(sayHello); // 2秒后输出：Hello!
```

#### 函数方法和原型

**函数也是对象，因此可以拥有自己的属性和方法**。通过将方法添加到函数对象的原型上，可以实现对所有实例都可用的共享方法

```js
// 定义一个构造函数
function Person(name) {
  this.name = name;
}

// 在原型上添加一个共享的方法
Person.prototype.sayHello = function() {
  console.log("Hello, my name is " + this.name);
};

// 创建两个实例
var person1 = new Person("Alice");
var person2 = new Person("Bob");

// 调用共享方法
person1.sayHello(); // 输出：Hello, my name is Alice
person2.sayHello(); // 输出：Hello, my name is Bob
```

## 数组:star:

创建略有不同，其他的没啥区别

#### 创建

```js
var fruits = ["apple", "banana", "orange"];
```

#### 获取长度`.length`

```js
console.log(fruits.length); // 输出：3
```

#### 末尾添加元素`.push`

```js
fruits.push("melon");
console.log(fruits); // 输出：["apple", "grape", "orange", "melon"]
```

#### 末尾删除元素`.pop`

```js
fruits.pop();
console.log(fruits); // 输出：["apple", "grape", "orange"]
```

#### 开头添加元素`.unshift`

```js
fruits.unshift("cherry");
console.log(fruits); // 输出：["cherry", "apple", "grape", "orange"]
```

#### 开头删除元素`.shift`

```js
fruits.shift();
console.log(fruits); // 输出：["apple", "grape", "orange"]
```

#### 数组排序`.sort`

```js
fruits.sort();
console.log(fruits); // 输出：["apple", "grape", "orange"]
```

#### 数组反转`.reverse`

```js
fruits.reverse();
console.log(fruits); // 输出：["orange", "grape", "apple"]
```

使用数组的高阶方法（如 `map`、`filter`、`reduce` 等）进行复杂的操作。

#### 注意：

1. 动态长度：可以随时添加或删除元素。数组不会限制其长度，可以根据需要动态扩展或缩减。
2. 类型灵活：**数组中的元素可以是不同的数据类型**，例如字符串、数字、布尔值、对象等。
3. 稀疏数组：即数组中包含空洞（未定义的元素）。这种情况下，数组的 `length` 属性可能会与实际元素数量不匹配，因此需要小心处理。
4. 数组长度： `length` 属性表示数组的长度，它是动态变化的。手动设置 `length` 属性时，数组会相应地增加或减少元素的数量。
5. 遍历方式： `for` 循环、`forEach` 方法、`for...of` 循环等。
6. 引用传递：数组是引用类型，**将一个数组赋给另一个变量时，实际上是将数组的引用复制给了新的变量**。
7. 数组方法的副作用：JavaScript 数组的许多方法（如 `push`、`pop`、`splice` 等）会修改原始数组。这些方法通常被称为有副作用的方法。如果你不希望修改原始数组，需要注意使用不会对原始数组产生影响的方法，或者在操作前先创建数组的副本。

## 对象

#### 创建：

- 使用对象字面量语法创建对象：
  ```javascript
  var person = {
    name: "John",
    age: 30,
    gender: "male"
  };
  ```

- 使用构造函数创建对象：
  ```javascript
  function Person(name, age, gender) {
    this.name = name;
    this.age = age;
    this.gender = gender;
  }
  
  var person = new Person("John", 30, "male");
  ```

#### 访问属性：

- 使用点号访问属性（属性名必须是一个合法的标识符）：
  ```javascript
  console.log(person.name); // 输出：John
  ```

- 使用方括号访问属性（属性名可以是一个字符串或表达式）：
  ```javascript
  console.log(person["age"]); // 输出：30
  
  var propertyName = "gender";
  console.log(person[propertyName]); // 输出：male
  ```

#### 修改属性：

```javascript
person.age = 35;
person["gender"] = "female";
```

#### 添加新属性：

```javascript
person.city = "New York";
person["occupation"] = "engineer";
```

#### 删除属性：

```javascript
delete person.age;
delete person["gender"];
```

#### 访问方法：

- 在对象字面量中定义方法：
  ```javascript
  var person = {
    name: "John",
    sayHello: function() {
      console.log("Hello, my name is " + this.name);
    }
  };
  
  person.sayHello(); // 输出：Hello, my name is John
  ```

- 使用构造函数定义方法：
  ```javascript
  function Person(name) {
    this.name = name;
    this.sayHello = function() {
      console.log("Hello, my name is " + this.name);
    };
  }
  
  var person = new Person("John");
  person.sayHello(); // 输出：Hello, my name is John
  ```

#### 注意：

1. 对象是引用类型：**将一个对象赋值给另一个变量时，实际上是将对象的引用复制给了新的变量**。修改其中一个变量的值会影响到另一个变量。
2. 属性的访问方式：**可以使用点号或方括号来访问对象的属性**。点号语法更常见且直观，但方括号语法可以使用变量作为属性名，灵活性更高。
3. 动态添加和删除属性：可以随时添加和删除。使用点号或方括号来添加新的属性，使用 `delete` 操作符来删除属性。
4. this 关键字：在对象的方法中，`this` 关键字指向当前对象。它可以用来访问当前对象的其他属性和方法。
5. 枚举对象的属性：可以使用 `for...in` 循环来枚举对象的所有可枚举属性。需要注意的是，该循环还会遍历继承的属性，因此可能需要通过 `hasOwnProperty()` 方法来检查属性是否是对象自身的属性。
6. JSON 格式：可以使用 `JSON.stringify()` 方法将对象转换为 JSON 字符串，使用 `JSON.parse()` 方法将 JSON 字符串转换回对象。
7. 使用对象字面量创建对象：对象字面量是一种简洁创建对象的方式，使用花括号 `{}` 并在其中定义属性和方法。这种方式适用于创建简单的、单个实例的对象。
8. 使用构造函数创建对象：可以使用构造函数和 `new` 关键字来创建对象。构造函数可以定义对象的属性和方法，并通过 `new` 关键字实例化一个对象。
9. 原型和继承：对象可以通过原型链来实现继承。对象可以继承其他对象的属性和方法，减少重复的代码。
10. 对象的深拷贝与浅拷贝：在对对象进行赋值或传递时，需要注意对象的拷贝方式。浅拷贝只复制对象的引用，而深拷贝会复制对象及其所有嵌套的属性和方法。

## 文档对象模型

#### 基本概念

[HTML DOM 教程 | 菜鸟教程 (runoob.com)](https://www.runoob.com/htmldom/htmldom-tutorial.html)

1. **一种表示和操作 HTML、XML 或 XHTML 文档结构的编程接口**。它将网页表示为一个树状结构，其中每个元素、属性、文本等都被表示为一个节点（node），并且这些节点可以通过 JavaScript 来进行访问和操作
2. DOM 提供了一组方法和属性，使开发者能够以编程方式对网页的结构、样式和内容进行修改。通过 DOM，可以动态地创建、删除、修改元素和属性，添加或移除事件处理程序，改变样式和类名，以及获取和修改网页的内容。

总结一句话作用：就是用于对一些标签啊、块啊，所有的元素都可以进行修改、获取等.

```js
<!DOCTYPE html>
<html>
  <head>
    <title>DOM Example</title>
  </head>
  <body>
    <div id="myDiv">Hello, World!</div>
    <button id="myButton">Click me</button>

    <script>
      // 获取元素节点，并修改其内容和样式
      var divElement = document.getElementById("myDiv");
      divElement.innerHTML = "Hello, DOM!";
      divElement.style.color = "red";

      // 添加事件处理程序
      var buttonElement = document.getElementById("myButton");
      buttonElement.addEventListener("click", function() {
        												alert("Button clicked!");
      																			}  );
    </script>
  </body>
</html>
```

## JS怎么操作HTML

JavaScript操控网页中的元素：如何使用JavaScript选择和修改HTML元素，以及如何添加、删除和修改元素的内容和样式？？？

**就是结合DOM的方式进行修改！！！**

## 鼠标监听

可以使用事件（event）来响应用户的交互行为。

1. **选择元素：** 首先，您需要选择要监听事件的HTML元素。您可以使用`document.querySelector`或`document.getElementById`等方法来获取元素的引用。

2. **添加事件监听器：** 一旦您选择了要监听事件的元素，接下来需要使用`addEventListener`方法添加事件监听器。该方法允许您指定要监听的事件类型和要执行的处理函数。

下面是一些常见的用户事件及其处理方法的示例：

#### 点击事件

```javascript
const button = document.querySelector('#myButton');

button.addEventListener('click', function() {
  alert('Button clicked!');
});
```

#### 鼠标移动事件

```javascript
const box = document.querySelector('#myBox');

box.addEventListener('mousemove', function(event) {
  console.log(`Mouse coordinates: X=${event.clientX}, Y=${event.clientY}`);
});
```

#### 键盘事件

```javascript
document.addEventListener('keydown', function(event) {
  console.log(`Key pressed: ${event.key}`);
});
```

#### 表单提交事件

```javascript
const form = document.querySelector('#myForm');

form.addEventListener('submit', function(event) {
  event.preventDefault(); // 阻止表单提交的默认行为
  console.log('Form submitted');
});
```

#### 输入事件

```javascript
const input = document.querySelector('#myInput');

input.addEventListener('input', function(event) {
  console.log(`Input value changed: ${event.target.value}`);
});
```

#### 更多事件类型

还有许多其他事件类型，如双击、右键点击、焦点变化、窗口大小改变等。您可以使用相应的事件类型名称，如`dblclick`、`contextmenu`、`focus`、`resize`等，来监听这些事件。

**注意**：事件处理函数可以是匿名函数（如上面的示例），也可以是已经定义的命名函数。



## 编写处理函数

编写事件处理程序涉及创建一个函数，该函数会在特定事件发生时被调用。然后，将该事件处理函数与特定的HTML元素关联起来，以便在事件发生时执行该函数。基本步骤：

1. **创建事件处理函数：** 首先，需要创建一个处理特定事件的函数。这个函数将定义您希望在事件发生时执行的操作。

2. **选择要关联的HTML元素：** 使用`document.querySelector`或其他选择器方法获取对您想要关联事件的HTML元素的引用。

3. **将事件处理函数与元素关联：** 使用`addEventListener`方法将事件处理函数与选定的HTML元素关联起来，以便在事件发生时调用该函数。

下面是一个简单的示例，演示了如何编写事件处理程序并将其与特定的HTML元素关联：

```html
<button id="myButton">Click Me!</button>

<script>
// 步骤1：创建事件处理函数
function handleClick() {
  alert('Button clicked!');
}

// 步骤2：选择要关联的HTML元素
const button = document.querySelector('#myButton');

// 步骤3：将事件处理函数与元素关联
button.addEventListener('click', handleClick);
</script>

```

## 异步JS和XML

是一种用于在不必刷新整个页面的情况下，通过在后台与服务器交换数据来更新页面部分的技术。尽管名称中包含XML，但实际上，现代的AJAX通常使用JSON等数据格式来传递数据。AJAX的核心思想是通过在后台发送HTTP请求并接收响应，从而实现与服务器之间的异步数据交换。

以下是AJAX的一般工作流程以及如何实现异步数据交互的概念：

1. **发起请求：** 使用JavaScript创建一个HTTP请求对象，该对象定义了要发送到服务器的请求类型（GET、POST等）、请求的URL和可能的其他参数。

2. **发送请求：** 使用该请求对象，通过`XMLHttpRequest`对象（或更现代的`fetch`API）将请求发送到服务器。这是一个异步操作，意味着JavaScript可以继续执行而无需等待服务器响应。

3. **服务器处理：** 服务器接收并处理请求，然后生成一个响应。服务器可以从数据库中获取数据、执行计算等。

4. **响应处理：** 一旦服务器发送响应，JavaScript将在后台接收它。您可以定义一个回调函数，用于处理来自服务器的数据。这使您能够更新页面内容，而无需刷新整个页面。

下面是一个使用原生`XMLHttpRequest`对象实现异步数据交互的简单示例：

```javascript
const xhr = new XMLHttpRequest();

xhr.open('GET', 'https://api.example.com/data', true); // 打开一个GET请求
xhr.onreadystatechange = function() {
  if (xhr.readyState === XMLHttpRequest.DONE) { // 请求完成
    if (xhr.status === 200) { // 响应成功
      const responseData = JSON.parse(xhr.responseText);
      // 在这里处理从服务器获取的数据
    } else {
      // 处理响应错误
    }
  }
};

xhr.send(); // 发送请求
```

对于更现代的做法，您还可以使用`fetch API`来实现异步数据交互：

```javascript
fetch('https://api.example.com/data')
  .then(response => {
    if (!response.ok) {
      throw new Error('Network response was not ok');
    }
    return response.json();
  })
  .then(data => {
    // 在这里处理从服务器获取的数据
  })
  .catch(error => {
    // 处理错误
  });
```

## JS的ToDoList练习

