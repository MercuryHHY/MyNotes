不管任何一项技术，首先了解其框架，很重要

还是那句话，快速跑起来获得正反馈，不要执迷于没有成就感的细节

大踏步向前，不求甚解都行，然后再去迭代，优化BUG



##  1	基本概念

数据库服务器：： 一台电脑上运行的服务器程序，主要用来存贮，管理  多个数据库

数据库（DB）：一个有组织的存贮数据的仓库

数据库管理系统（DBMS）：：管理数据库的软件，列如MySQL，需要连接服务器

SQL：：使用人员通过	数据库管理系统	管理数据库的语言，它是一套统一的标准



注意：：不管是以后使用哪一款**数据库管理系统**，使用者都是使用SQL语言管理数据库，换句话说，只是中间的软件（DBMS）或者使用的图形化工具软件不一样而已



安装MySQL的一系列软件以后，电脑作为	**数据库服务器**

用户在安装的MySQL的客户端软件中连接DBMS

在客户端中 通过SQL语言操作 数据库管理系统（DBMS） 来管理数据库



一个数据库管理系统 可以 在 **数据库服务器** 中 创建多个  数据库  ，一个数据库可以创建多个表



## 2	MySQL图形工具的使用（dateGrip）

利用这个工具可以连接到MySQL，此工具比命令窗口方便简介，开发效率更高，可根据用户的选择设置	以此自动生成SQL语句，从而操作数据库管理系统来管理数据库

注意，通过光标的选中执行所需要的语句



点击此图标可设置要展示的数据库

<img src="typora-user-images\image-20230613123529274.png" alt="image-20230613123529274" style="zoom: 50%;" />



点击这里，可以创建数据库

<img src="typora-user-images\image-20230613123756020.png" alt="image-20230613123756020" style="zoom:50%;" />



进入后，指定数据库名称，别名

主机名，端口号

用户名，密码



![image-20230613124119373](C:\Users\gg\AppData\Roaming\Typora\typora-user-images\image-20230613124119373.png)



点击OK即可



图形工具的操作无法复制，但是利用SQL语言写好脚本，重新运行可以完美复刻一个数据库

这也是数据库保存的一种方式





## 3	SQL语言注意事项

在DQL语句中，不能删除表中的数据，select  只能过滤掉设置的数据展示出来，而不是修改删除数据

他只有查询的作用



在DCL语句中   %  表示的主机名      意思是任意主机都可以访问数据库

在数据库中，用户名是指被允许连接到数据库的用户的名称。每个用户必须具有唯一的用户名，以便系统可以识别和验证其身份。用户名通常与密码相结合，用于控制对数据库中数据的访问权限。

主机名是指尝试连接到数据库的计算机的名称或IP地址。当用户从一个计算机上连接到数据库服务器时，他们需要提供主机名或IP地址来建立连接。这是因为数据库服务器可以在不同的计算机上运行，并且只有知道正确的主机名才能与之通信。

因此，数据库中的用户名和主机名都是用于管理和控制对数据库的访问权限的重要组成部分。



用户名就相当于账号名

主机名，就是 可访问数据库的电脑              要么是           当前的当地主机    或者    是被允许的其他主机电脑

数据库用  用户名关联主机名





**在SQL语言中，0值不是null，0与null不相等**

**但是 0==false       1==true**



## 4，case when then else end

第一种情况

```SQl
select
       name,
       	(case  workaddress
            when "北京" then "一线城市" 
         	when "上海" then "一线城市"
            else  "二线" 
         end)
  		as "工作城市等级"
from emp;
```

case选择 workaddress 工作地址，当他是北京的时候  返回“一线城市”，当他是上海的时候  返回“一线城市”

else 其他情况返回“二线”，end结束



第二种情况

```SQL
case
    when math<60 then "不及格" 
    when math>=60&&math<80 then "及格"
    else "优秀" 
end as "数学等级",
```

直接当when后面条件满足，返回then后面的

与上面有微小区别



在 SQL 中，CASE 表达式用于进行条件判断和根据不同条件返回不同值。它类似于编程语言中的 switch 语句。

用法如下：

```sql
CASE
    WHEN condition1 THEN result1
    WHEN condition2 THEN result2
    ...
    ELSE result
END
```

其中 condition1、condition2 等是要判断的条件，result1、result2 等是条件成立时返回的值，ELSE 子句是可选的，用于指定当没有条件成立时返回的默认值。

举个例子，假设有一个名为 `users` 的表，其中包含 `name` 和 `age` 列。我们想根据用户的年龄进行分类，可以使用 CASE 表达式来实现：

```sql
SELECT
    name,
    CASE
        WHEN age < 18 THEN '未成年'
        WHEN age >= 18 AND age < 60 THEN '成年'
        ELSE '老年'
    END AS age_group
FROM
    users;
```

这个查询会返回所有用户的名字和根据年龄分类后的年龄组别。















## 5	外键约束

用来管理数据库中各个表中数据的规范

当在图形表中操作表时，可以用快捷键Ctrl+Enter 执行当前操作，或者右键工具窗口，

或者点击直接点击快捷图标



添加外键

```SQL
#在创建表的时候指定外键
CREATE TABLE 表名(
字段名 数据类型,
...
[CONSTRAINT] [外键名称] FOREIGN KEY (外键字段名) REFERENCES 主表 (主表列名)
);

#修改增加表的外键
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段名)
REFERENCES 主表 (主表列名) ;
```



当删除/更新行为发生时，语法如下

```SQL
ALTER TABLE 表名 ADD CONSTRAINT 外键名称 FOREIGN KEY (外键字段) REFERENCES
主表名 (主表字段名) ON UPDATE cascade ON DELETE CASCADE;
```

示例

```SQl
alter table emp add constraint fk_emp_dept_id foreign key (dept_id) references
dept(id) on update cascade on delete cascade ;
```



设置从表emp中的dept_id为该表的外键，外键接的是主表dept中的id字段，在update以及delete 行为中

设置cascade级联操作，意思是一旦一改具改，一删具删，主从一体





## 6	外连接

外连接分为 左外连接和右外连接  本质上实现的功能是一样的，可替换

语法如下

```SQL
SELECT 字段列表 FROM 表1 LEFT [ OUTER ] JOIN 表2 ON 条件 ... ; 

select 字段列表 from 表1 left [outer]   join 表2 on 条件 ... ;
```



如下面两条的语句效果一样的

```SQl
select  d.*,  e.*
    from emp e
    right  join dept d on e.dept_id=d.id;
#取出从right右边的表（dept）的所有数据，并且包含    满足on条件后的 另一个表（emp）的数据


select  d.*,e.*
    from dept d
    left join  emp e on e.dept_id=d.id;
#取出从left左边的表（dept）的所有数据，并且包含    满足on条件后的 另一个表（emp）的数据
```





## 7	自连接

### 1	自连接查询

一张表自己连接自己，自连接时将一张表当成是两张表用

如下

```SQl
select a.name , b.name from emp a , emp b where a.managerid = b.id; 
#注意 必须取别名 ，不然就乱了
```

既然一张表当作两张表用

那么，自连接 也就有  内连接和外连接

```SQL
select a.name '员工', b.name '领导' from emp a left join emp b on a.managerid =
b.id;
```



### 2	联合查询

对于union查询，就是把多次查询的结果合并起来，形成一个新的查询结果集。

将两次查询到的表合并到一起，

但是

对于联合查询的多张表的列数（查询的字段列表）必须保持一致，字段类型也需要保持一致。



注意：

union all 会将全部的数据直接合并在一起，

union 会对合并之后的数据去重。



## 8	列子查询中的操作符说明

```SQL
any/some
#子查询返回列表中，有任意一个满足即可

all
#子查询返回列表的所有值都必须满足

in 
#在指定的集合范围之内，多选一

not in
#在指定的集合范围之外

```



示例如下：：

```SQL 
#比 财务部 所有人工资都高的员工信息 ,比最高的还高  全满足的条件 &&
select * from emp where salary > all ( select salary from emp where dept_id =
(select id from dept where name = '财务部') );

#比研发部其中任意一人工资高的员工信息 ，满足任意一个条件即可，  ||
select * from emp where salary > any ( select salary from emp where dept_id =
(select id from dept where name = '研发部') );



```



## 9	多表查询

​	1、不需要外键

​	2、多表查询中，注意下列

```SQl
select d.id,d.name,( select count(*) from emp e where e.dept_id=d.id )'人数'
    from dept d ;
```



思考为啥下面的代码不行

```SQl
select count(*) from emp e,dept d where e.dept_id=d.id;

/*
	在这行代码中，where 的条件将会不起到应有的作用，他只能去除emp中dept_id 为null的成员
	他最终只是会计算出非空的总和
	要想得到每个部门的人数，那么参考下面代码
*/

select d.id,d.name,( select count(*) from emp e where e.dept_id=d.id )'人数'
    from dept d ;
```





## 10 	事务

### 1	注意：：

当一条SQL语句执行成功之后，在还没有提交之前，如果报错了，利用回滚操作可以不提交回到数据开始的初始值

但是，这一条语句确实是执行成功了，当下一次提交时，这一次成功的执行还是会提交成功

如下所示：：

```SQL

begin ;
-- 1. 查询张三余额
select * from account where name = '张三';

-- 2. 张三的余额减少1000
update account set money = money + 1000 where name = '张三';

这里故意出一个错
update  jdafksdj;

-- 3. 李四的余额增加1000
update account set money = money - 1000 where name = '李四';

commit;

rollback ;
```

第二步的操作执行成功之后，下一条执行报错，代码停止在这里，执行成功的语句还没有提交，

所以原始数据没有改变，可是下一次提交时，这次的成功执行的也会一起被提交，数据会出现混乱



### 2	并发引发的问题

#### 1	脏读

一个事务读到了另外一个事务还没有提交的数据

一个客户端在读取数据时，读到了另一个客户端还没有提交的数据，导致的数据混乱，很致命





#### 2	不可重复读：

不可重复读：一个事务先后读取同一条记录，但两次读取的数据不同，称之为不可重复读

一个客户端执行的一个事务，因为在两次读取的中间，有其他客户端的事务对数据库做了改变，所以导致前后两次读取的数据不一致



#### 3	幻读

一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据
已经存在，好像出现了 "幻影"。

一个客户端的一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据没显示

但是确实已经存在，好像出现了 "幻影"，这是因为另一个客户端改变了数据库的相关数据，使得这条数据确实存在了





### 3	事务隔离级别的说明



一个隔离级别对于并发3个问题的处理方式不同

如果隔离级别不够，那么问题还存在，这自然不用多说



那么隔离级别处理3个问题之后效果如下

##### 1	脏读处理

隔离级别达到之后，脏读不再存在，

此时，一个客户端的事务不会再读到另一个客户端没有提交的数据



##### 2	不可重复读 处理

隔离级别达到之后，不可重复读  不再存在

此时，一个客户端的一个事务 可以确保前后两次读取的数据一致，不管外面客户端是否对原始数据库做了改变



##### 3	幻读处理

隔离级别达到之后，幻读  不再存在

在一个客户端（1号）中设置隔离级别之后，此时，另一个客户端（2号）对于数据库相关数据的改变（增删改）不会成功，

2号会阻塞等待，他必须等1号提交完成之后，他才能解除阻塞来执行

确保我1号在处理的时候，你2号不能处理

此时的1号幻读问题，完美解决







## 视图

在 SQL 中，视图（View）是一个虚拟表，它是基于一个或多个表的查询结果构建的。视图可以被视为一个已命名的、可用作表的子集的查询结果。它并不存储实际的数据，而是通过执行定义视图时的查询来获取数据。

使用视图有以下几个优点：

1. 简化复杂的查询：可以使用视图将复杂的查询逻辑封装起来，使查询变得简单明了。

2. 保护数据安全性：可以向用户提供只能访问特定子集数据的视图，同时隐藏底层表的结构和敏感数据。

3. 提供数据的逻辑组织：视图可以对数据进行逻辑上的组织和分组，便于数据的管理和使用。

创建视图的语法如下：

```sql
CREATE VIEW view_name AS
SELECT column1, column2, ...
FROM table_name
WHERE condition;
```

其中 `view_name` 是视图的名称，`column1, column2, ...` 是需要选择的列，`table_name` 是基于哪些表创建视图，`condition` 是可选的筛选条件。

举个例子，假设有一个名为 `orders` 的表，包含 `order_id`、`customer_id` 和 `order_date` 列。我们想创建一个只包含特定客户的订单的视图：

```sql
CREATE VIEW customer_orders AS
SELECT order_id, order_date
FROM orders
WHERE customer_id = '12345';
```

这样，我们就创建了一个名为 `customer_orders` 的视图，它只包含客户 ID 为 '12345' 的订单信息。之后可以像操作表一样，对这个视图进行查询操作。







## 存储过程

在 SQL 中，存储过程（Stored Procedure）是一组预编译的 SQL 语句，它们被存储在数据库中并分配了一个名称。存储过程可以包含输入参数、输出参数、局部变量、流程控制语句（如条件和循环）、SQL 语句等，它们被封装在一个可重复调用的单元中。

存储过程的使用有以下几个优点：

1. 减少网络流量：由于存储过程是在数据库服务器上执行的，而不是在客户端上执行，因此可以减少网络流量。

2. 提高性能：存储过程在数据库服务器上进行预编译和优化，执行效率更高。

3. 简化复杂操作：存储过程可以封装复杂的业务逻辑和操作，简化应用程序代码。

创建存储过程的语法如下：

```sql
CREATE PROCEDURE procedure_name (parameters)
BEGIN
    -- 存储过程的逻辑
END;
```

其中 `procedure_name` 是存储过程的名称，`parameters` 是可选的输入参数，可以指定多个参数，每个参数都有名称和数据类型。

举个例子，假设要在数据库中创建一个存储过程，用于根据客户 ID 获取订单信息。存储过程接收客户 ID 作为输入参数，并返回相关的订单信息：

```sql
CREATE PROCEDURE get_orders_by_customer_id (IN customer_id INT)
BEGIN
    SELECT order_id, order_date
    FROM orders
    WHERE customer_id = customer_id;
END;
```

调用存储过程来获取订单信息：

```sql
CALL get_orders_by_customer_id(12345);
```

上面的示例中，我们创建了一个名为 `get_orders_by_customer_id` 的存储过程，该存储过程接收一个 INT 类型的输入参数 `customer_id`。在存储过程的逻辑中，我们使用了 SELECT 语句来查询具有指定客户 ID 的订单，并返回结果。最后，通过 `CALL` 关键字来调用存储过程传递参数。



